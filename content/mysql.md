# MySQL

## 数据库范式了解吗？

- **1NF（第一范式）：**属性不可分
- **2NF（第二范式）：**每个非主属性完全依赖于键码
- **3NF（第三范式）：**非主属性不传递函数依赖于键码



## 主键和外键

- **主键（主码）：**用于标识一个元组，不能有重复，不允许为空。一个表只能有一个主键
- **外键（外码）：**用来和其他表建立联系用，外键是另一个表的主键



## 为什么不推荐使用外键与级联？

**外键与级联更新适用于单机低并发，不适合分布式、高并发集群**

级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度

对分库分表不友好：分库分表下外键是无法生效的



## 什么是存储过程？

阿里巴巴Java开发手册里要求禁止使用存储过程

存储过程难以调试和扩展，更没有移植性



## 数据库设计通常分为哪几步?

**需求分析**：分析用户的需求，包括数据、功能和性能需求；

**概念结构设计**：主要采用E-R模型进行设计，包括画E-R图；

**逻辑结构设计**：通过将E-R图转换成表，实现从E-R模型到关系模型的转换；

**数据库物理设计**：主要是为所设计的数据库选择合适的存储结构和存取路径；

**数据库的实施**：包括编程、测试和试运行；

**数据库运行与维护**：系统的运行与数据库的日常维护



## 事务

事务指的是满足 ACID 特性的一组操作，可以通过 Commit 提交一个事务，也可以使用 Rollback 进行回滚

#### ==ACID==

1. **原子性**
   - 事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚
2. **一致性**
   - 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的
3. **隔离性**
   - 一个事务所做的修改在最终提交以前，对其它事务是不可见的
4. **持久性**
   - 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响

![QQ_1720665492442](D:\桌面\Java\MySQL.assets\QQ_1720665492442.png)

>
>
>==🌈注意:==**只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！**
>
> 
>
>==MySQL 默认采用自动提交模式。如果不显式使用`START TRANSACTION`语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。==
>
>

##### ⭐️MySQL如何保证原子性?

在MySQL中,恢复机制是通过==回滚日志(undo log)==实现的,所有事务进行的修改都会记录在这个回滚日志中,然后再执行相关操作



## ⭐️ 并发事务问题(并发一致性问题)

#### 丢失修改

**A , B两个事务修改同一个数据 , A事务先修改该数据 , B后修改该数据 , 这样A事务的修改结果就被丢失 , 因此称为**==丢失修改==

  

 

#### ==脏读==

**A , B 两个事务**

**A 事务修改数据但事务未提交 , 而 B 事务读取到了 A 事务未提交的数据**

==通俗的讲就是当前事务读到的数据是别的事务想要修改的数据但是没有修改成功的数据==

![QQ_1720667453926](D:\桌面\Java\MySQL.assets\QQ_1720667453926.png)

 

#### ==不可重复读==

**A 事务多次读同一个数据 , 在A事务进行的时候 ,B事务修改了改数据 ,导致A事务前后读取的数据不一样**



==当前事务先进行了一次数据读取，然后再次读取到的数据是别的事务修改成功的数据，导致两次读取到的数据不匹配==

![QQ_1720667638654](D:\桌面\Java\MySQL.assets\QQ_1720667638654.png)

#### ==幻读==

==当前事务第一次读取到的数据比后来读取到数据条目不一致==



#### 不可重复读与幻读的区别?

现象不同

- 不可重复读是指在同一个事务中，二次读取同一行数据的结果不一致
- 幻读是指在同一个事务中，二次执行相同的查询，结果集的行数不一致

产生原因

- 不可重复读通常是由于数据的更新或删除导致的
- 幻读通常是由于数据的插入导致的

解决方法

- 不可重复读可以通过可重复读或者可串行化解决
- 幻读可以通过最高的事务隔离级别解决



## ⭐️ 事务的==隔离级别==

#### 未提交读

- 事务中的修改,即使没有提交,对其它事务也是可见的
- 可能导致脏读、幻读或不可重复读

#### 提交读

- 允许读取并发事务已经提交的数据,可以阻止脏读
- 幻读、不可重复读仍可能发生

#### 可重复读

- 保证在同一个事务中多次读取同样数据的结果是一致的
- 可以阻止脏读和不可重复读，但幻读仍有可能发生

#### 可串行化

- 最高的隔离级别，完全服从 ACID 的隔离级别
- 该级别可以防止脏读、不可重复读以及幻读



## ⭐️ 多版本并发控制(MVCC)

用于在多个并发事务同时读写数据库时保持数据的一致性和隔离性



MVCC 通过创建数据的多个版本和使用快照读取来实现并发控制。读操作使用旧版本数据的快照，写操作创建新版本，并确保原始版本仍然可用。



MVCC的设计目的是为每个事务提供一致的快照视图，以避免读操作和写操作之间的冲突。因此，当一个事务开始时，它的读视图固定在该时刻的数据库状态。要看到其他事务提交的新数据，需要重新开始一个新事务



####  💡MVCC的实现原理?

- **通过在每行数据线行上维护多个版本的数据来实现的**
  - 即当一个事务要对数据库中的数据进行修改时,MVCC会为该事务创建一个数据快照,而不是直接修改实际的数据行
- **事务的时间戳或事务ID**
  - 每个事务在开始时都会分配一个唯一的时间戳或事务ID，用来标识事务的开始时间。这是 MVCC 实现的一部分，用于判断哪些版本的记录对该事务可见
- **==快照读取==**
  - 当一个事务开始时，它会创建一个一致性视图（Consistent View）
  - 这个视图包含了在事务开始时所有已提交的数据。后续的查询操作将基于这个视图进行
- **垃圾回收**
  - 数据库系统会定期进行垃圾回收，删除那些已经没有任何事务需要访问的旧版本数据。

## 🌈SQL语法

#### LINIT

限制返回的行数

```sql
#返回前5行
SELECT * FROM mytable LIMIT 5;

#返回第 3 ~ 5 行
SELECT * FROM mytable LIMIT 2, 3;
```



#### 排序

- **ASC :**升序
- **DESC :**降序

```sql
#可以按多个列进行排序，并且为每个列指定不同的排序方式
SELECT *
FROM mytable
ORDER BY col1 DESC, col2 ASC;
```



#### 子查询

子查询只能返回一个字段的数据

```sql
#将子查询的结果作为 WHRER 语句的过滤条件
SELECT *
FROM mytable1
WHERE col1 IN (SELECT col2
               FROM mytable2);
```



#### 连接

==INNER JOIN 关键字==

==AS关键字为表取别名==

- #### 内连接

  - 内连接又称等值连接，使用 INNER JOIN 关键字

  - ```sql
    #内连接查询
    SELECT A.value, B.value
    FROM tablea AS A INNER JOIN tableb AS B
    ON A.key = B.key;
    
    #普通查询
    SELECT A.value, B.value
    FROM tablea AS A, tableb AS B
    WHERE A.key = B.key;
    ```

    

- #### 自连接

  - 自连接可以看成内连接的一种，只是连接的表是自身而已

  - ```sql
    #子查询
    SELECT name
    FROM employee
    WHERE department = (
          SELECT department
          FROM employee
          WHERE name = "Jim");
    
    #自连接
    SELECT e1.name
    FROM employee AS e1 INNER JOIN employee AS e2
    ON e1.department = e2.department
          AND e2.name = "Jim";
    
    ```

    

- #### 自然连接

- #### 外连接



#### 事务处理

**MySQL 默认是隐式提交**，每执行一条语句就把这条语句当成一个事务然后进行提交。当出现 `START TRANSACTION` 语句时，会关闭隐式提交；当 `COMMIT` 或 `ROLLBACK` 语句执行后，事务会自动关闭，重新恢复隐式提交。



```sql
-- 开始事务
START TRANSACTION;

-- 插入操作 A
INSERT INTO `user`
VALUES (1, 'root1', 'root1', 'xxxx@163.com');

-- 创建保留点 updateA
SAVEPOINT updateA;

-- 插入操作 B
INSERT INTO `user`
VALUES (2, 'root2', 'root2', 'xxxx@163.com');

-- 回滚到保留点 updateA
ROLLBACK TO updateA;

-- 提交事务，只有操作 A 生效
COMMIT;

```



#### 查询去重

关键字 ==`DISTINCT`==

```sql
#查询单列去重
SELECT DISTINCT column_name
FROM table_name;
```



##  ⭐️SQL优化

#### 一.负向查询不能使用索引

负向查询通常指的是包含==`NOT`关键词==的查询，例如`NOT condition`或者`field_name != value`这样的查询

原因:

- 索引通常是为了加速特定条件下的查询，而负向查询会涉及到不匹配某些条件的数据

#### 二.前导模糊查询不能使用索引

前导模糊查询是指==以通配符开头==的查询，例如 `LIKE '%keyword'`

```sql
select name from user where name like "%王"
```

原因:

- 大多数数据库索引（如 B-Tree 索引）是基于前缀匹配进行优化的
- 索引可以快速查找到以特定前缀开头的记录,以通配符开头的查询，索引无法确定查找的起点和终点



#### 三.在字段上进行计算或者使用函数不能命中索引

```sql
#对索引进行表达式计算
SELECT * FROM table WHERE field + 1 = 100;

#对索引使用函数
SELECT * FROM table WHERE length(field)= 100;

```

需要对字段`field`进行计算后,再进行比较,相当于全表查询

索引是基于字段的原始值进行排序和存储的



#### ⛳️四.最左前缀问题

==最左前缀法则 :== 多列索引(复合索引)是由多个列组成的索引，数据库引擎在创建和使用这些索引时，会按照定义的列顺序来处理查询条件

```sql
#如果该表的复合索引为{id,name.age}
#能够满足
select name from user where id=1 and name = "age";
select name from user where id=1;
select name from user where id=1 and name = "age" or age = 12;

#不满足的
select name from user where name = "age";
```

#### 五.关键词`or`

```sql
#id是主键索引，name字段没有索引
select name from user where id=1 or name = "age";
```

#### 六.不要让数据库帮我们做强制类型转换

```sql
#虽然能查出数据，但是可能会导致全表查询
#name是 varcher
select name from user where name = 2161444985;
```

#### 七.如果需要进行join的字段两表的字段类型要相同





## 🎯存储引擎

#### InnoDB

- MySQL默认的事务型存储引擎

- 默认的事务隔离级别为：可重复读

  - 在InnoDB中可重复读的实现原理

    1. MVCC（多版本并发控制）

       - 数据快照：事务开始时，会创建一个一致性视图
       - 隐藏列：每行记录都会有两个隐藏列，用于存储事务ID(`DB_TRX_ID`：记录最近一次修改该行的事务ID；`DB_ROLL_PTR`：指向之前的版本，用于实现回滚操作)

    2. 下一键锁（Next-Key Lock）：行锁和间隙锁的组合，锁住索引记录本身以及前后的间隙

       ==通过下一键锁与MVCC能够有效的防止幻读==

- 支持真正的在线热备份

- 支持外键

- 行级锁，表级锁

- 主索引是聚簇索引（在索引中保存了数据，从而避免直接读取磁盘，提升查询性能）

  





#### MyISAM

- 不支持事务，不支持外键
- 只支持表级锁
- 崩溃概率高，恢复速度慢



## ==索引==

索引相当于书籍的目录



#### B+树比B树好在哪里？

- B+树的主要特征：

  - 所有实际数据存储在叶子节点
  - 非叶子节点存储关键字用于索引
  - 叶子节点通过链表连接

- B树：所有节点都存储实际数据，叶子节点不形成链表

  >B+树的优点：
  >
  >1. 因为叶子节点是链表，拥有一些链表的优点，删除，插入更高效
  >2. 因为所有的数据到存储在叶子节点上，就拥有了更高的存储利用率，查询也更加方便

#### 索引的分类

- ##### 按底层存储方式

  - 聚簇索引：索引结构和数据一起存放。每个表只能有一个聚簇索引
  - 非聚簇索引

- ##### 按应用维度划分

  - 主键索引
  - 普通索引
  - 唯一索引
  - 联合索引（复合索引）：涉及到最左匹配原则

- ##### 按数据结构划分

  - ==B+树索引==
  - 哈希索引

#### 主键索引

数据表的主键列使用的就是主键索引

一张表只有一个主键，且主键不能为null，不能重复

在MySQL的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引且不允许存在为null值的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个自增主键



## ==⭐️性能优化；====⭐️慢查询优化==

主要的还是索引的使用和索引优化

通过explain来查看，是否使用到索引

慢查询是指数据库中查询时间超过指定阈值的SQL

#### 使用`Explain`进行分析

```sql
EXPLAIN SELECT * FROM `account`
```

![QQ_1721201610038](D:\桌面\Java\MySQL.assets\QQ_1721201610038.png)

- `select_type`：查询类型
- `key`：使用的索引
- `row`：扫描的行数

#### 优化数据访问

1. #### 减少请求的数据量

   - 只返回必要的列，避免`select *`
   - 只返回必要的行，使用`limit`限制返回的数据
   - 缓存热点数据，避免同一个数据多次在数据库查询

2. #### 减少服务器端扫描的行数



#### 重构查询方式

1. #### 切分大查询(将大查询拆分成多个小查询)

   原始大查询

   ```sql
   SELECT * FROM orders;
   ```

   

   - 切分查询【关键词 `BETWEEN  AND`】

     ```sql
     SELECT * FROM orders WHERE order_id BETWEEN 1 AND 10000;
     SELECT * FROM orders WHERE order_id BETWEEN 10001 AND 20000;
     SELECT * FROM orders WHERE order_id BETWEEN 20001 AND 30000;
     ```

     

   - 分页查询 【关键词`LIMIT`】

     ```sql
     SELECT * FROM orders LIMIT 0, 1000;
     SELECT * FROM orders LIMIT 1000, 1000;
     SELECT * FROM orders LIMIT 2000, 1000;
     ```

     

2. #### 分解大连接查询（将连接查询拆分成多个小查询）

   原始大连接查询

   ```sql
   #两个表orders和customers
   SELECT o.order_id, o.order_date, c.customer_name
   FROM orders o
   JOIN customers c ON o.customer_id = c.customer_id;
   ```

   - 将连接操作分成多个步骤

     - 查询订单表`orders`并将结果存储在临时表中

       ```sql
       CREATE TEMPORARY TABLE temp_orders AS
       SELECT order_id, order_date, customer_id FROM orders;
       ```

       

     - 查询客户表`customers`并将结果存储在临时表中

       ```sql
       CREATE TEMPORARY TABLE temp_customers AS
       SELECT customer_id, customer_name FROM customers;
       ```

       

     - 最终进行连接查询

       ```sql
       SELECT o.order_id, o.order_date, c.customer_name
       FROM temp_orders o
       JOIN temp_customers c ON o.customer_id = c.customer_id;
       ```

   - 使用子查询

     ```sql
     SELECT o.order_id, o.order_date, c.customer_name
     FROM orders o
     JOIN (SELECT customer_id, customer_name FROM customers) c
     ON o.customer_id = c.customer_id;
     ```

   - 按范围切分查询

   - 将连接查询分解成多个单表查询，并在代码中进行关联





## ⭐️数据库相关的锁

#### 按读写分类

- 共享锁(S)：允许多个事务同时读取，但不能进行写操作
- 排他锁(X)：允许加锁的事务进行读写操作，但其他事务不能进行任何操作

#### 按粒度分类

- 表级锁：对整个表加锁，防止其他事务对该表进行并发操作
- 行级锁：对单行记录进行加锁，允许更高的并发性

#### 按索引锁分类    

- 间隙锁：基于非唯一索引，它锁定一段范围内的索引记录，以防止幻读
- 临建锁：结合行锁和间隙锁，它的封锁范围，既包含索引记录，又包含索引区间，是一个左开右闭区间

#### 按锁的使用方式分类

- 乐观锁：系统假设在事务执行过程中不会发生冲突，因此在数据读取时不会加锁，而是在提交数据时进行冲突检测
- 悲观锁：系统假设在事务执行过程中会发生冲突，因此在数据读取和修改时都会加锁，以确保数据的独占访问

#### 意向锁

意向锁是表锁，为了协调行锁和表锁的关系，支持多粒度（表锁与行锁）的锁并存。

- 意向共享锁（IS）
- 意向排他锁（IX）

#### ==全局锁==

加锁后，整个数据库处于只读状态；主要用于数据备份

缺点：备份数据时，因为处于只读状态，可能导致业务停滞

在InnoDB存储引擎+可重复读的隔离级别下，应为有数据快照，且有MVCC的支持，备份数据时仍然可以执行其他业务



## 分表分库

#### 1.水平切分

#### 2.垂直切分

#### 3.Sharding策略

## 主从复制与读写分离







## ⭐️什么是 SQL 注入？

SQL 注入是一种网络攻击技术，攻击者通过操作输入数据中的 SQL 查询语句，使得应用程序执行未经授权的操作。

它利用了应用程序在构建 SQL 查询时对用户输入的数据缺乏适当的验证和清理的漏洞

**SQL 注入的基本原理：**

​	在典型的 SQL 注入攻击中，攻击者通过输入恶意的 SQL 代码，使得数据库执行意外的操作

==*一个简单的例子：*==

>假设有一个登录表单，用户输入用户名和密码，应用程序会执行以下SQL查询来验证用户身份：
>
>```sql
>SELECT * FROM users WHERE username = 'user' AND password = 'password';
>```
>
>如果应用程序没有正确处理用户输入的数据，攻击者可能会输入以下内容：
>
>- 用户名：` OR '1'='1'`
>- 密码：`OR '1'='1'`
>
>生成的SQL查询将变为：
>
>```sql 
>SELECT * FROM users WHERE username = '' OR '1'='1' AND password = '' OR '1'='1';
>```
>
>这条查询语句将总是返回true，从而绕过了登录验证，允许攻击者登录到系统中。

**防止 SQL 注入的方法：**

- **使用预编译语句**：通过将查询语句与数据分离来避免恶意代码的注入

  >预编译语句：SQL 查询的结构被定义，但具体的参数值尚未指定
  >
  >例如：JDBC
  >
  >```Java
  >String sql = "SELECT * FROM users WHERE username = ? AND password = ?";
  >PreparedStatement pstmt = connection.prepareStatement(sql);
  >pstmt.setString(1, "exampleUsername"); // 设置第一个参数的值
  >pstmt.setString(2, "examplePassword"); // 设置第二个参数的值
  >ResultSet rs = pstmt.executeQuery();
  >
  >```
  >
  >SQL查询语句中的参数`username`和`password`被用`?`占位。
  >
  >通过`setString`方法为这些占位符设置具体的值。
  >
  >SQL查询的结构在准备阶段就已经确定，而不会因为用户输入的数据而改变，从而有效地防止了SQL注入。

- **输入验证**： 严格限制和验证用户输入的数据，例如使用正则表达式验证输入格式

- **使用存储过程（不推荐）**：存储过程可以封装数据库操作，避免直接暴露SQL查询

- **限制数据库用户权限**：为数据库用户设置最小权限，避免不必要的数据访问

- **使用 Web 应用防火墙(WAF)**：WAF可以帮助检测和阻止潜在的SQL注入攻击







# NoSQL

## NoSQL是什么?

 NoSQL  泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。

NoSQL数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案

NoSQL数据库代表：==MongoDB、Redis== 



## NoSQL 数据库有什么优势？

- **灵活性：**NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选

  

- **可扩展性：**NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展

  

- **高性能：**NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能

  

- **强大的功能：**NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建



## NoSQL数据库有那些类型？

NoSQL 数据库主要可以分为下面四种类型：

- **键值**：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。

  

- **文档**：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。

  

- **图形**：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。

  

- **宽列**：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。

