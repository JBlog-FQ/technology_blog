# 常见的设计模式

## 一.创建型模式

==主要处理对象的创建问题，通过封装对象创建过程来提高系统的灵活性和可扩展性==

- **单例模式**

  确保一个类只有一个实例，并提供全局访问点。常用于需要共享资源的场景，如配置文件管理、数据库连接池等。

  ```Java
  public class Singleton{
      //私有静态实例，确保全局唯一
      private static Singleton instance;
      
      //私有构造方法，防止外部实例化
      private Singleton(){}
      
      //公共静态方法，提供访问点
      public static Singleton getInstance(){
          if(instance == null){
              instance = new Singleton();
          }
          return instance;
      }
  }
  ```

  

- **工厂方法模式**

  定义一个创建对象的接口，但让子类决定实例化哪个类。使得一个类的实例化延迟到子类。

  ```java
  // 产品接口
  interface Product {
      void use();
  }
  
  // 具体产品A
  class ConcreteProductA implements Product {
      @Override
      public void use() {
          System.out.println("Using Product A");
      }
  }
  
  // 具体产品B
  class ConcreteProductB implements Product {
      @Override
      public void use() {
          System.out.println("Using Product B");
      }
  }
  
  // 工厂方法抽象类
  abstract class Creator {
      public abstract Product factoryMethod();
  
      public void operation() {
          Product product = factoryMethod();
          product.use();
      }
  }
  
  // 具体工厂A
  class ConcreteCreatorA extends Creator {
      @Override
      public Product factoryMethod() {
          return new ConcreteProductA();
      }
  }
  
  // 具体工厂B
  class ConcreteCreatorB extends Creator {
      @Override
      public Product factoryMethod() {
          return new ConcreteProductB();
      }
  }
  ```

  

- **抽象工厂模式**

  提供一个创建一系列相关或依赖对象的接口，而无需指定它们的具体类。通常用于创建一组相关的产品，如不同操作系统的UI组件。

- **建造者模式**

  将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。常用于构建复杂对象如多步骤的对象创建流程。

- **原型模式**

  通过复制现有实例来创建新对象，避免创建新对象的代价。适用于需要大量类似对象创建的场景。

## 二.结构型模式

==主要关注如何在系统中组合类或对象以实现更大的灵活性和扩展性==

- **适配器模式**
  将一个类的接口转换为客户期望的另一个接口，使得原本由于接口不兼容而不能一起工作的类可以协同工作。适用于“旧系统适配新系统”的场景。
- **桥接模式**
  将抽象部分与实现部分分离，使它们都可以独立变化。适用于需要多个维度变化的场景，如不同平台的UI控件。
- **装饰器模式**
  动态地给对象添加职责。与继承相比，装饰器模式提供了一种更加灵活的给对象添加功能的方式。
- **外观模式**
  为子系统中的一组接口提供一个一致的接口，使得子系统更容易使用。常用于简化复杂子系统的使用。
- **享元模式**
  通过共享对象来减少内存消耗，适用于大量相似对象的场景。常用于文本编辑器字符对象的共享。
- **代理模式**
  为另一个对象提供一个代理，以控制对该对象的访问。常用于延迟加载、访问控制等场景。

## 三.行为型模式

==主要关注对象之间的通信与职责分配==

- **策略模式**
  定义一系列算法，将每一个算法封装起来，并使它们可以互相替换。策略模式使得算法可以独立于使用它的客户而变化。
- **观察者模式**
  定义对象间的一种一对多依赖关系，当一个对象的状态发生变化时，所有依赖于它的对象都得到通知并自动更新。常用于实现事件驱动的系统。
- **命令模式**
  将请求封装成一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。
- **责任链模式**
  将请求的处理者链式组织起来，每个处理者都有机会处理请求，直到有处理者处理了它。常用于构建灵活的职责分配机制。
- **中介者模式**
  用一个中介对象来封装一系列对象之间的交互。中介者使各对象不需要显式地相互引用，从而使耦合松散，而且可以独立地改变它们之间的交互。
- **备忘录模式**
  在不破坏封装的前提下，捕获并保存一个对象的内部状态，以便可以在以后将对象恢复到这个状态。
- **迭代器模式**
  提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。常用于遍历集合。
- **模板方法模式**
  在一个方法中定义一个算法的框架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下重新定义算法的某些步骤。
- **访问者模式**
  表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。
- **状态模式**
  允许对象在内部状态改变时改变其行为。看起来对象改变了它的类。常用于处理对象状态变化的复杂逻辑。